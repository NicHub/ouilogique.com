
    <svg
        id = "centered_polygonal_number_svg"
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        shape-rendering="crispEdges"
        viewBox="-40 -40 80 80">

        <!--
            Use this viewBox if the SVG is standalone.
            viewBox="-20 -20 40 40"
         -->

        <!--
        Idea from:
        https://stackoverflow.com/q/77922222/3057377

        See also:
        https://en.wikipedia.org/wiki/Centered_polygonal_number
    -->

        <title>Centered polygonal number</title>
        <desc>Centered polygonal number</desc>


        <style>
            /*
            Style can be applied to individual dots by targeting their IDs.
            For instance, the 10th dot can be accessed as follows:
            #c10 { fill: red; }

            If you want to display the IDs themselves, comment the `display none` statement below.

            Style can also be applied to the dots within a specific layer by targeting their class.
            For instance, the dots on the 2nd layer can be accessed as follows:
            .l2 { fill: hsl(110, 45%, 75%); stroke: hsl(110, 45%, 65%); }

            The last layer has an extra class called `.llast`.

            Style can also be applied to slices.
            For instance, the slices 1 to 6 can be accessed as follow:
            .s1,.s2,.s3,.s4,.s5,.s6{ fill: hsl(0, 0%, 95%); stroke: hsl(0, 0%, 85%); }
            */
            svg { background-color: rgba(255, 255, 255, 0); }
            text { text-anchor: middle; font-size: 4px; font-family: monospace; fill: hsl(0, 0%, 30%); z-index: 1000; dominant-baseline: middle; text-shadow: #FFF 0 0 20px; }
            text.dottext {
                fill: hsl(0, 0%, 0%);
                font-size: 1px;
                stroke: none;
            }
            circle { fill: hsl(0, 0%, 30%); stroke: hsl(0, 0%, 70%); stroke-width: 0.2; opacity: 0.6; }
            .l0 { fill: hsl(0, 80%, 80%); stroke: hsl(0, 80%, 70%); }
            .l1 { fill: hsl(150, 65%, 67%); stroke: hsl(150, 65%, 57%); }
            .l2 { fill: hsl(110, 45%, 75%); stroke: hsl(110, 45%, 65%); }
            .l3 { fill: hsl(255, 50%, 80%); stroke: hsl(255, 50%, 70%); }
            .l4 { fill: hsl(120, 30%, 48%); stroke: hsl(120, 30%, 38%); }
            .llast { fill: hsl(90, 100%, 50%); stroke: hsl(90, 100%, 40%); }
            /*
            .s1,.s2,.s3,.s4,.s5,.s6{ fill: hsl(0, 0%, 95%); stroke: hsl(0, 0%, 85%); }
            */

            @media print {
                @page {
                    size: 40mm 40mm;
                    margin: 0;
                    padding: 0;
                }
            }
        </style>

        <g id="svg_container"></g>

        <script type="application/ecmascript">
    <![CDATA[

    "use strict";


    function rotatePoint(_x, _y, angle_rad) {
        const newX = _x * Math.cos(angle_rad) - _y * Math.sin(angle_rad);
        const newY = _x * Math.sin(angle_rad) + _y * Math.cos(angle_rad);
        return { x: newX.toFixed(3), y: newY.toFixed(3) };
    }


    /**
    *   Initialization of CPN, the object containing
    *   the data for the centered polygonal number.
    *   When calling the function `centered_polygonal_number`,
    *   the first 4 properties must be provided.
    *   The other properties are then computed.
    */
    let CPN = {
        side_count  : 6,
        layer_count : 4,
        layer_gap   : 3,
        dot_radius  : 1,
        display_ids : false,
        dot_count   : null,
        coords      : [{
            is_last_layer : null,
                    layer : null,
                    side : null,
                    dot : null,
                        x : null,
                        y : null,
        }],
    };


    /**
    * Optional: Override CPN initial values with GET parameters if present.
    * Example URL:
    * centered_polygonal_numbers.svg?side_count=5&layer_count=3&layer_gap=2&dot_radius=0.5
    */
    const urlParams = new URLSearchParams(window.location.search);
    for (const _p of urlParams) {
        if (CPN.hasOwnProperty(_p[0])) {
            CPN[_p[0]] = _p[1];
        };
    }


    /**
    * Draw with initial values.
    */
    centered_polygonal_number(CPN);


    function centered_polygonal_number(cpn) {
        cpn = compute_centered_polygonal_number(cpn);
        drawSVG(cpn);
    }


    function compute_centered_polygonal_number(cpn) {
        cpn.side_count = parseInt(cpn.side_count);
        cpn.layer_count = parseInt(cpn.layer_count);
        cpn.layer_gap = parseFloat(cpn.layer_gap);
        cpn.dot_radius = parseFloat(cpn.dot_radius);

        // Math stuff.
        const angle1_deg = 360 / cpn.side_count;
        const angle1_rad = 2 * Math.PI / cpn.side_count;
        const angle2_rad = (Math.PI - angle1_rad) / 2;
        const dist_dot2_dot3 = 2 * cpn.layer_gap * Math.sin(angle1_rad / 2);
        const dx = -dist_dot2_dot3 * Math.cos(angle2_rad);
        const dy = -dist_dot2_dot3 * Math.sin(angle2_rad); // SVG y sign is opposite to usual carthesian repr.
        cpn.dot_count = cpn.side_count * cpn.layer_count / 2 * (cpn.layer_count - 1) + 1;

        // Calculate rotation offset to ensure that the polygon lies flat on one side.
        const rot_offset_flat =
            (cpn.side_count - 2) % 4 === 0
            ? 0
            : (Math.PI - angle1_rad) / 2;

        // Calculate the coordinates of the dots and some metadata.
        cpn.coords = [];
        for (let _i = 0; _i < cpn.layer_count; _i++) {
            // Iterate by layer:
            // - All layers: Iterate from 0 to cpn.layer_count - 1.
            const is_last_layer = _i == cpn.layer_count - 1;
            const jmax = _i > 0 ? cpn.side_count : 1;
            const kmax = _i > 0 ? _i - 1 : 0;
            for (let _j = 0; _j < jmax; _j++) {
                // Iterate by polygon side:
                // - First layer: Iterate once.
                // - Other layers: Iterate from 0 to to cpn.side_count - 1.
                const angle_rad = -angle1_rad * _j + rot_offset_flat;
                for (let _k = 0; _k <= kmax; _k++) {
                    // Iterate by dot.
                    // - First layer: Iterate once.
                    // - Other layers: Iterate from 0 to to layer_index - 1.
                    const _x = _i * cpn.layer_gap + _k * dx;
                    const _y = _k * dy;
                    const xy = rotatePoint(_x, _y, angle_rad);
                    cpn.coords.push({
                is_last_layer : is_last_layer,
                        layer : _i,
                         side : _j,
                          dot : _k,
                            x : xy.x,
                            y : xy.y,
                    });
                }
            }
        }
        return cpn;
    }


    function drawSVG(cpn) {
        let svg_string = ``;

        // Add the dots and the text on them if CPN.display_ids is true.
        for (let _i = 0; _i < cpn.coords.length; _i++) {
            const layer_class = cpn.coords[_i].is_last_layer
                ? `l${cpn.coords[_i].layer} llast`
                : `l${cpn.coords[_i].layer}`;
            const side_class = `s${cpn.coords[_i].side}`;
            svg_string += `<circle id = "c${_i}"
                                class = "${layer_class} ${side_class}"
                                   cx =  "${cpn.coords[_i].x}"
                                   cy =  "${cpn.coords[_i].y}"
                                    r =  "${cpn.dot_radius}" />\n`
            if (! CPN.display_ids) { continue };
            svg_string +=   `<text id = "t${_i}"
                                class =  "${layer_class} ${side_class} dottext"
                                    x =  "${cpn.coords[_i].x}"
                                    y =  "${cpn.coords[_i].y}"
                                            >${_i}</text>\n`;
        }

        // Add the numerical representation of the Centered Polygonal Number.
        svg_string += `<text id="dot_count" x="0" y="-16">${cpn.dot_count}</text>`;

        // Update display.
        const svg_container = document.getElementById("svg_container")
        svg_container.innerHTML = svg_string;
    }


    ]]>
            </script>

        </svg>
